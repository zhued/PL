# Lab 2

Edward Zhu; Partner - Steven Tang

### 1. Grammars: Synthetic Examples
**a.**  Rewrite Grammer
	
	Axioms:

	a is in VObjects; b is in VObjects

	----------------			----------------
	a is in VObjects			b is in VObjects


	Premises and conclusion:

    S1 is in AObjects S2 is in AObjects
    ---------------------------------------
            S1 & S2 is in AObjects  
              			                   			                      	              
              S is in VObjects
             -----------------
              S is in AObjects
			              	

**b.** Show it is ambiguous.

		   A				
		/    \
       A      A
     /  \     |
    A    A    V   	
    |	  |   |
    b     a   b

		   A
		/    \
       A      A
       |     / \
       V    A   A
       |    |   |
       b    a   b

Both of the trees yield the sentence b & a & b with different paths of arrival, thus showing that it is ambiguous.

**c.** The language can either produce one or more a's, zero or multiple b's, or one or more c's. 
NOTE: There can only be one grouping at a time (A, B, or C only)

**d.**

	1. baab CAN be generated by the given grammar.
		AaBb => baBb => baab

	2. bbbab CANNOT be generated by the given grammar.
		AaBb => AbaBb => AbbaBb => bbbaBb =/> bbbab
		bbbaBb will require 'B' to be aB|a, thus it cannot become bbbab

	3. bbaaaaa CANNOT be generated by the given grammar.
		AaBb => AbaBb => bbaBb => bbaBab => bbaaBb =/> bbaaaaa
		bbaaaaa ends with an 'a', there is no possible way to end with an 'a' because the grammar requires a 'b' at the end

	4. bbaab CAN be generated by the given grammar.
		AaBb => AbaBb => bbaBb => bbaab

**e.**

	1. abcd CAN be generated by the given grammar.
	    S
	 / / \ \
	a S   c B
	| |   | |
	a b   c d

	2. acccbd CANNOT be generated by the given grammar.
	    S
	 / / \ \
	a S   c B
	| |   | |
	a A   c d

	As seen above, 'c' must be in front of 'B' (which would produce our 'd'), and in order for the pattern to be 'bd' at the end, it be derived from SB, which is not possible.

	3. acccbcc CANNOT be generated by the given grammar.
	    S
	 / / \ \
	a S   c B
	| |   | |
	a A   c A

	As seen above, the there is no way after that step that will allow the 'b' to exist after a string of 'c' because 'S' is the only way to produce a 'b' and it is also needed for 'A' that can produce a string of c. 

	4. acd CANNOT be generated by the given grammar.
	    S
	 / / \ \
	a S   c B
	| |   | |
	a A   c A

	There are three variables, and according to the behavior to the grammer, there must be at least 4 variables if the variables needed are 'a' 'c' 'd', but there are only 3. 

	5. accc CAN be generated by the given grammar.
		S
	 / / \ \
	a S   c B
	| |   | |
	a A   c A
	| |   | |
	a c   c c

### 2. Grammars: Synthetic Examples
**a.**

**i.**The first grammar is produces either 'operand' or 'e operator operand' and recursively calls e.

	OPERAND
	OPERAND OPERATOR OPERAND
	OPERAND OPERATOR OPERAND OPERATOR OPERAND ...

The second grammer produces either operand esuffix. And esuffix will produce operator operand esuffix, or an empty string. And it will recursively call esuffix.

	OPERAND
	OPERAND OPERATOR OPERAND
	OPERAND OPERATOR OPERAND OPERATOR OPERAND ...

**ii.** These grammars would generate the same expressions, but may generate different parse trees. See above for possible outcomes of each. They both have the behavior of generating 'operand' with a number of 'operator operand' following it or the empty set. The main difference is that the first grammar is left-associative while the second is right-associative.

**b.** Expression:

	--> 5-2 << 3		--> 2 << 5 - 3
	--> (5-2) << 3		--> 2 << (5 - 3)
	--> 3 << 3			--> 2 << 2
	--> INT = 24		--> INT = 8

**c** Below is the BNF grammar for the question:
	
	FLOAT ::= UNARY INTS NUM.NUM | UNARY INTS NUM.NUM EXP
	NUM ::= ZERO NUM | INT NUM
	INTS :: INT | INT INTS | EMPTY
	INT ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	ZEROS ::= 0 | 0 ZEROS
	UNARY ::= - | EMPTY
	EXP ::= E UNARY INTS NUM


### Scala exercices
See Lab2.scala

To run the auto-grader:

	sbt test
	sbt "project lab2-grader" run

To run the jsy file:

	sbt "run <path_to_jsy_file>"